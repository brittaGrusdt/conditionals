// State prior  --------------------------------------------------------------
// var p_ac_ind = {"none": 0.25,
//                 "lawn": 0.0,
//                 "pizza" : 1,
//                 "dutchman" : 1
//                 }
// var cn_prior = function(bias) {
//   var p_ind = p_ac_ind[bias]
//   var p_dep = (1 - p_ind) / (globalStore.cns.length - 1)
//   var ps = map(function(cn){cn == "A || C" ?  p_ind : p_dep}, globalStore.cns)
//   return categorical({vs: globalStore.cns, ps: ps})
// }

var log_likelihood = function(state){
  var p = cn_to_prob(state)
  return state.cn == "A || C" ?
          Gaussian({mu:p[0]*p[1], sigma: globalStore.indep_sigma}).score(p[2]) :
          (Beta({a:10, b:1}).score(p[0]) + Beta({a:1, b:10}).score(p[1]))
}

var state_prior = cache(function(bias){
  var distr = Infer({method:'enumerate', model:function(){
    var TableID = uniformDraw(globalStore.Tables)
    var Table = TableID.Table
    var state = {"table": Table,
                 "cn": uniformDraw(globalStore.cns),
                 "id": TableID.id}
                 // "cn": cn_prior(bias)}
    factor(log_likelihood(state))

    var intention = uniformDraw(globalStore.speaker_intents)
    if(bias=='lawn'){
      // possibility 1: P(C|¬A)
      // var p = Math.exp(Table.score("-AC")) / marginal(Table, ["-A"])
      // condition(p <= 0.1)
      // possibility 2: P(¬A,C)
      var p = Math.exp(Table.score("-AC"))
      condition(p <= 0.1)

    } else if(bias=="pizza"){
      condition(state.cn == "A || C")
    } else if(bias == "dutchman"){
      condition(marginal(Table, ["C"]) <= thresholds.f)
    }
    return {"bn": state, "intention": intention}
  }})

  // make sure that states that have almost 0-probability are excldued,
  // otherwise these states face a problem for the speaker who cannot say
  // anything because the log of the literal listener will always be -Infinity
  return Infer({model:function(){
    var s = sample(distr)
    condition(Math.exp(distr.score(s)) > 0.0000011)
    return s
  }})
})
