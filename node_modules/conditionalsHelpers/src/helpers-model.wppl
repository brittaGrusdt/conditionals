// var thresholds = {t: 0.899, f: 0.0499, theta: 0.899, theta_likely : 0.499}
// var thresholds = {t: 0.899, f: 0.0499, theta: 0.749, theta_likely : 0.499}

// @arg table: probability distribution
// @arg variables <str>, e.g.["A", "C"]
// computes the marginal probability of P(X, Y, ..) for all input variables
var marginal = cache(function(table, variables){
  var tokens = table.support()
  var all_x = map(function(v){
    v.startsWith("D") ? filter(function(k){k.indexOf(v) != -1}, tokens) :
    v.indexOf("-") != -1 ? filter(function(k){k.indexOf(v) != -1}, tokens) :
                           filter(function(k){k.indexOf("-"+v) == -1}, tokens)
  }, variables)
  var xs = intersect_arrays(all_x)

  return reduce(function(x, acc){acc + Math.exp(table.score(x))}, 0, xs)
})

var conditional_probs = cache(function(table){
  return {"P(C|A)" : marginal(table, ["A", "C"]) / marginal(table, ["A"]),
          "P(C|-A)": marginal(table, ["-A", "C"]) / marginal(table, ["-A"]),
          "P(A|C)" : marginal(table, ["A", "C"]) / marginal(table, ["C"]),
          "P(A|-C)": marginal(table, ["A", "-C"]) / marginal(table, ["-C"]),
          "P(C|Da)": marginal(table, ["C", "Da"]) / marginal(table, ["Da"]),
          "P(C|Db)": marginal(table, ["C", "Db"]) / marginal(table, ["Db"]),
          "P(C|Dna)": marginal(table, ["C", "Dna"]) / marginal(table, ["Dna"]),
          "P(C|B)" : marginal(table, ["B", "C"]) / marginal(table, ["B"]),
          "P(C|A,B)": marginal(table, ["C", "A", "B"]) / marginal(table, ["A", "B"]),
          "P(C|A,-B)": marginal(table, ["C", "A", "-B"]) / marginal(table, ["A", "-B"]),
          "P(C|-A,B)": marginal(table, ["C", "-A", "B"]) / marginal(table, ["-A", "B"]),
          "P(C|-A,-B)": marginal(table, ["C", "-A", "-B"]) / marginal(table, ["-A", "-B"])
        }
}, 10000)

var cn_to_prob = cache(function(state){
  var cn = state.cn
  var table = state.table
  var probs = conditional_probs(table)
  return cn == "A implies C" ? [probs["P(C|A)"], probs["P(C|-A)"]] :
         cn == "A implies -C" ? [1 - probs["P(C|A)"], 1 - probs["P(C|-A)"]] :
         cn == "-A implies C" ? [probs["P(C|-A)"], probs["P(C|A)"]] :
         cn == "-A implies -C" ? [1 - probs["P(C|-A)"], 1 - probs["P(C|A)"]] :
         cn == "C implies A" ? [probs["P(A|C)"], probs["P(A|-C)"]] :
         cn == "C implies -A" ? [1 - probs["P(A|C)"], 1 - probs["P(A|-C)"]] :
         cn == "-C implies A" ? [probs["P(A|-C)"], probs["P(A|C)"]] :
         cn == "-C implies -A" ? [1 - probs["P(A|-C)"], 1 - probs["P(A|C)"]] :
         cn == "A || C" ? [marginal(table, ["A"]), marginal(table, ["C"]),
                           marginal(table, ["A", "C"])] :
         // cn ==  "A,B->D->C" ? [probs["P(C|Da)"], probs["P(C|Db)"]] :
         (cn ==  "A,B->D->C" || cn == "A,B->C") ?
          [probs["P(C|A,B)"], probs["P(C|A,-B)"], probs["P(C|-A,B)"], probs["P(C|-A,-B)"]] :
         cn == "only A implies C" ? [probs["P(C|A)"], probs["P(C|-A)"]] :
  error('unknown network: ' + cn)
}, 10000)

var connect_variables = function(var_powerset, connective){
  var connected_vars = mapIndexed(function(idx, first_set){
    var rest_sets = var_powerset.slice(idx+1)
    var sets_to_pair = filter(function(rest_i){
      all(function(x){
        rest_i.indexOf(x) == -1 && rest_i.indexOf(negate(x)) == -1
      }, first_set)
    }, rest_sets)
    var elems_to_pair = map(function(set_i){set_i.join(" and ")}, sets_to_pair)

    var antecedent = first_set.join(" and ")
    var ifs = reduce(function(key, acc){
      acc.concat([antecedent + connective + key, key + connective + antecedent])
    }, [], elems_to_pair)
    return ifs
  }, var_powerset)

  var filtered = filter(function(arr){arr.length >= 1}, connected_vars)
  var connected_vars = reduce(function(arr, acc){
    acc.concat(arr)
  }, [], filtered)

  return connected_vars
}


// ----- UTTERANCES ----- //
var make_utterances = function(var_powerset){
  var conj_literals = map(function(set_i){set_i.join(" and ")}, var_powerset)
  var pos_conj = filter(function(utt){utt.indexOf(" and ") != -1}, conj_literals)
  // var neg_conj = map(function(conj){"-(" + conj + ")"}, pos_conj)
  var literals = filter(function(utt){utt.indexOf(" and ") == -1}, conj_literals)
  var likelys = map(function(lit){"likely " + lit}, literals)
  var conditionals = connect_variables(var_powerset, " > ")

  // var conditionals_likely = map(function(cond){cond.replace(">", "> likely")}, conditionals)
  var conditionals_likely = []
  var conditionals_q = globalStore.bias == "judy" ? map(function(cond){cond.replace(">", ">q")}, conditionals) : []
  var conditionals_all = conditionals.concat(conditionals_likely.concat(conditionals_q))

  // var conjunctions = pos_conj.concat(neg_conj)
  // var utterances = literals.concat(conjunctions.concat(likelys.concat(conditionals)))

  var utterances = conj_literals.concat(likelys.concat(conditionals_all))
  return utterances
}

var utterance_probs = cache(function(utterance, Table){
  if(utterance.indexOf(">") != -1){
    // var components = utterance.split(" > ")
    var components = utterance.includes(" > likely ") ? utterance.split(" > likely ") :
                     utterance.includes(" >q ") ? utterance.split(" >q ")
                                                : utterance.split(" > ")
    var antecedent = components[0].split(" and ").join("")
    var consequent = components[1].split(" and ").join("")
    return marginal(Table, [antecedent, consequent]) /
           marginal(Table, [antecedent])
    // var neg_consequent = negate(consequent)
    // return marginal(table, [antecedent, neg_consequent])
  }
  else if(utterance.includes("likely")){
    var u = utterance.slice("likely ".length)
    return marginal(Table, [u])
  }
  else if(utterance.includes("-(") & utterance.includes("and")){
    var i = utterance.indexOf(")")
    display('i: ' + i)
    display(utterance)
    var utterance = utterance.slice(2,i)
    var components = utterance.split(" and ")
    return marginal(Table, components)
  }
  else if(utterance.includes("and")){
    var components = utterance.split(" and ")
    return marginal(Table, components)
  }
  else {
    return marginal(Table, [utterance])
  }
})

var costs = cache(function(utt){
  if(globalStore.utterances.indexOf(utt)== -1){error('unknown utterance ' + utt)}
  var c1 = utt.includes(' > ') ? globalStore.cost_conditional : 0
  var c2 = (utt.split(' and ').length - 1) * (globalStore.cost_conditional/2)
  var c3 = utt.split('-').length > 1 ?  (globalStore.cost_conditional/4) : 0
  var c4 = utt.includes('likely') ? (globalStore.cost_conditional/5) : 0
  return c1 + c2 + c3 + c4
}, 10000)


// Meaning ------------------------------------------------------------------
var meaning = cache(function(utterance, table){
 var p = utterance_probs(utterance, table)
 var u_applicable =
  utterance == "" ? true :
  utterance.includes('>q') ?
  ((p >= globalStore.judy_q - 0.025) && (p <= globalStore.judy_q + 0.025)) :
  (utterance.includes('likely') ?
  p >= globalStore.thresholds.theta_likely : p >= globalStore.thresholds.theta)
  // (p >= globalStore.thresholds.theta_likely) :
  // (utterance.includes('-(') ? p <= 1-globalStore.thresholds.theta : p >= globalStore.thresholds.theta)

 // display(utterance + " " + p + " " + u_applicable)
 return u_applicable
})


var speaker_conditions = function(utt, Table, probs) {
  // p_rooij/p_delta larger than a threshold
  if(utt == "p_rooij") {
    return probs.p_rooij >= 0.75
  } else if(utt == "p_delta") {
    return probs.p_delta > 0 && probs.p_c_given_a >= 0.75;
  } else if(utt.startsWith("uncertain")){
    // only states where speaker is uncertain about A and/or C
    // (uncertainA/uncertainC/uncertainAC)
    let holdsA = utt.includes("A") ? (probs.pa > (1 - globalStore.thresholds.theta)) &&
            (probs.pa < (globalStore.thresholds.theta)) : true;

    let holdsC = utt.includes("C") ? (probs.pc > 1 - globalStore.thresholds.theta) &&
            (probs.pc < globalStore.thresholds.theta) : true;
    return holdsA || holdsC;

  } else if(utt.startsWith("certain")){
    // only states where speaker is certain about A/-A and/or C/-C
    // (certainA/certainC/certainAC)
    let holdsA = utt.includes("A") ? (probs.pa > globalStore.thresholds.theta)
      || (probs.pa < 1 - globalStore.thresholds.theta) : true;

    let holdsC = utt.includes("C") ? (probs.pc > globalStore.thresholds.theta)
      || (probs.pc < 1 - globalStore.thresholds.theta) : true;
    return holdsA || holdsC;

  } else if(utt != ""){
    return meaning(utt, Table)
  } else {
    // simply accept
    return true
  }
}
