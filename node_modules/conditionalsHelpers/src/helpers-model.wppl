var thresholds = {t: 0.899, f: 0.0499, theta: 0.899, theta_likely : 0.499}

var marginal = cache(function(table, variables){
  // computes the probability of P(A) marginalized over all other variables in
  // support of table with P=table and variables=["A"]
  var tokens = table.support()
  var all_x = map(function(v){
    v.indexOf("-") != -1 ? filter(function(k){k.indexOf(v) != -1}, tokens) :
                           filter(function(k){k.indexOf("-"+v) == -1}, tokens)
  }, variables)
  var xs = intersect_arrays(all_x)

  return reduce(function(x, acc){acc + Math.exp(table.score(x))}, 0, xs)
})

var conditional_probs = cache(function(table){
  return {"P(C|A)" : marginal(table, ["A", "C"]) / marginal(table, ["A"]),
          "P(C|-A)": marginal(table, ["-A", "C"]) / marginal(table, ["-A"]),
          "P(A|C)" : marginal(table, ["A", "C"]) / marginal(table, ["C"]),
          "P(A|-C)": marginal(table, ["A", "-C"]) / marginal(table, ["-C"])}
}, 10000)

var cn_to_prob = cache(function(state){
  var cn = state.cn
  var table = state.table
  var probs = conditional_probs(table)
  return cn == "A implies C" ? [probs["P(C|A)"], probs["P(C|-A)"]] :
         cn == "A implies -C" ? [1 - probs["P(C|A)"], 1 - probs["P(C|-A)"]] :
         cn == "-A implies C" ? [probs["P(C|-A)"], probs["P(C|A)"]] :
         cn == "-A implies -C" ? [1 - probs["P(C|-A)"], 1 - probs["P(C|A)"]] :
         cn == "C implies A" ? [probs["P(A|C)"], probs["P(A|-C)"]] :
         cn == "C implies -A" ? [1 - probs["P(A|C)"], 1 - probs["P(A|-C)"]] :
         cn == "-C implies A" ? [probs["P(A|-C)"], probs["P(A|C)"]] :
         cn == "-C implies -A" ? [1 - probs["P(A|-C)"], 1 - probs["P(A|C)"]] :
         cn == "A || C" ? [marginal(table, ["A"]), marginal(table, ["C"]),
                           marginal(table, ["A", "C"])] :
  error('unknown network: ' + cn)
}, 10000)

var connect_variables = function(var_powerset, connective){
  var connected_vars = mapIndexed(function(idx, first_set){
    var rest_sets = var_powerset.slice(idx+1)
    var sets_to_pair = filter(function(rest_i){
      all(function(x){
        rest_i.indexOf(x) == -1 && rest_i.indexOf(negate(x)) == -1
      }, first_set)
    }, rest_sets)
    var elems_to_pair = map(function(set_i){set_i.join(" and ")}, sets_to_pair)

    var antecedent = first_set.join(" and ")
    var ifs = reduce(function(key, acc){
      acc.concat([antecedent + connective + key, key + connective + antecedent])
    }, [], elems_to_pair)
    return ifs
  }, var_powerset)

  var filtered = filter(function(arr){arr.length >= 1}, connected_vars)
  var connected_vars = reduce(function(arr, acc){
    acc.concat(arr)
  }, [], filtered)

  return connected_vars
}


// ----- UTTERANCES ----- //
var make_utterances = function(var_powerset){
  var conjunctions_literals = map(function(set_i){set_i.join(" and ")},
                                  var_powerset)
  var literals = filter(function(utt){utt.indexOf(" and ") == -1},
                       conjunctions_literals)
  var likelys = map(function(lit){"likely " + lit}, literals)

  var conditionals = connect_variables(var_powerset, " > ")
  var utterances = conditionals.concat(conjunctions_literals.concat(likelys))
  return utterances
}

var utterance_probs = cache(function(utterance, table){
  if(utterance.includes(">")){
    var components = utterance.split(" > ")
    var antecedent = components[0].split(" and ").join("")
    var consequent = components[1].split(" and ").join("")
    return marginal(table, [antecedent, consequent]) /
           marginal(table, [antecedent])
    // var neg_consequent = negate(consequent)
    // return marginal(table, [antecedent, neg_consequent])
  }
  else if(utterance.includes("likely")){
    var u = utterance.slice("likely ".length)
    return marginal(table, [u])
  }
  else if(utterance.includes("and")){
    var components = utterance.split(" and ")
    return marginal(table, components)
  }
  else {
    return marginal(table, [utterance])
  }
})

var costs = cache(function(utt){
  if(globalStore.utterances.indexOf(utt)== -1){error('unknown utterance ' + utt)}
  var c1 = utt.includes(' > ') ? globalStore.cost_conditional : 0
  var c2 = (utt.split(' and ').length - 1) * (globalStore.cost_conditional/2)
  var c3 = utt.split('-').length > 1 ?  (globalStore.cost_conditional/4) : 0
  var c4 = utt.includes('likely') ? (globalStore.cost_conditional/5) : 0
  return c1 + c2 + c3 + c4
}, 10000)


// Meaning ------------------------------------------------------------------
var meaning = cache(function(utterance, table){
 var p = utterance_probs(utterance, table)
 var u_applicable = utterance.includes('likely') ?
                      (p >= thresholds.theta_likely) : p >= thresholds.theta
// utterance.includes(">") ? ((p >= degree - 0.025) & (p <= degree + 0.025)) :  p >= thresholds.theta
 return u_applicable
})
