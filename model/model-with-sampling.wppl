////////////  SET PARAMETERS  /////////////////
globalStore.alpha = 5
globalStore.thetaCP = 0.05
var thresholds = {t: 0.899, f: 0.0499, theta: 0.899, theta_maybe : 0.499}

var vars = [["A", "-A"], ["C", "-C"]]
var n_tables = 1000
// Helper --------------------------------------------------------------------
var roundToN = function(x, n){
  var m = Math.pow(10,n)
  return Math.round(x*m)/m
}

var negate = function(x){
  return x.startsWith("-") ? x.slice(1) : "-" + x
}

var combinations = Infer({model:function(){
  var bools = repeat(vars.length, flip)
  var tokens = mapIndexed(function(idx, b){
    b ? uniformDraw(vars[idx]) : ""
  }, bools)
  return filter(function(t){t.length>0}, tokens)
}}).support()
var combinations = filter(function(x){x.length > 0}, combinations)
display('# unique combinations of pairs: ' + combinations.length)

var combine_pairs = function(connective){
  var pairs_list = mapIndexed(function(idx, tokens1){
    var arr = filter(function(tokens){
      all(function(x){
        !tokens.includes(x) && !tokens.includes(negate(x))
      }, tokens1)
    }, combinations.slice(idx+1))

    var antecedent = tokens1.join(" and ")
    var ifs = map(function(tokens2){
      antecedent + connective + tokens2.join(" and ")
    }, arr)

    var ifs_rev = map(function(tokens2){
      tokens2.join(" and ") + connective + antecedent
    }, arr)
    return ifs.concat(ifs_rev)
  }, combinations)

  var pairs = reduce(function(arr, acc){
    acc.concat(arr)
  }, [], pairs_list)
  return pairs
}

var intersect_arrays = function(arrays){
  return filter(function(m){
          var m_in_all_lists = map(function(idx){arrays[idx].includes(m)},
                                  _.range(1,arrays.length))
          return sum(m_in_all_lists)==m_in_all_lists.length
    }, arrays[0])
}

// Causal networks  ----------------------------------------------------------
var dependent_nets = combine_pairs(" implies ")
var causal_nets = ["A || C"].concat(dependent_nets)

// Probabilities ------------------------------------------------------------
var prob_ac_ind = {"none": 1/2,
                   "lawn": 0.1,
                   "pizza" : 1,
                   "BC-impossible-cons": 1
                  }

var marginal = function(state, variables){
  // computes the probability of P(A) marginalized over all other variabls in support of state
  // with P=state and variables=["A"]
  var tokens = state.support()
  var all_x = map(function(v){
    v.includes("-") ? filter(function(k){k.includes(v)}, tokens) :
                      filter(function(k){!k.includes("-"+v)}, tokens)
  }, variables)
  var xs = intersect_arrays(all_x)

  return reduce(function(x, acc){acc + Math.exp(state.score(x))}, 0, xs)
}

// States --------------------------------------------------------------------
var build_table_functions = {
  "A/-A implies" : cache(function(c_a, c_na, a){
                          return {"AC": c_a * a, "A-C": (1-c_a) * a,
                                  "-AC": c_na * (1-a), "-A-C": (1-c_na) * (1-a)
                                 }
                         }),
  "C/-C implies" : cache(function(a_c, a_nc, c){
                          return {"AC": a_c * c, "A-C": a_nc * (1-c),
                                  "-AC": (1-a_c) * c, "-A-C": (1-a_nc) * (1-c)
                                 }
                         }),

  "||" : cache(function(a, c){
                return {"AC": a * c, "A-C": a * (1-c),
                        "-AC": (1-a) * c, "-A-C": (1-a) * (1-c)}
                }),
}

var tables = function(cn){
  var build_table = cn.includes(" || ") ? build_table_functions["||"] :
                      cn.startsWith("A") || cn.startsWith("-A") ?
                        build_table_functions["A/-A implies"] :
                        build_table_functions["C/-C implies"]

  var table_distributions =
    Infer({method:'forward', samples:n_tables, model:function(){
      var child_p = beta(10,1)
      var child_np = beta(1,1) // or predefined small value beta
      var parent = beta(1,1)
      var probs =
        cn=="A || C" ? [child_np, parent] :
        cn=="A implies C" || cn=="C implies A" ? [child_p, child_np, parent] :
        cn=="A implies -C" || cn=="C implies -A" ? [1-child_p, 1-child_np, parent] :
        cn=="-A implies C" || cn=="-C implies A" ? [child_np, child_p, 1-parent] :
        cn=="-A implies -C" || cn=="-C implies -A" ? [1-child_np, 1-child_p, 1-parent] :
        error("unknown causal network " + cn)

      var table = cn=="A || C" ? build_table(probs[0], probs[1])
                                 : build_table(probs[0], probs[1], probs[2])
      return Categorical({"vs": Object.keys(table),"ps": Object.values(table)})
  }}).support()
  return table_distributions
}

var cn_prior_probs = cache(function(p_ind){
  return [p_ind].concat(repeat(dependent_nets.length,
                               function(){(1-p_ind)/dependent_nets.length}))
})

var cn_prior = function(bias) {
  return categorical({vs: causal_nets, ps: cn_prior_probs(prob_ac_ind[bias])})
}

var state_prior = cache(function(bias){
  return Infer({method:'enumerate', model:function(){
    var cn = cn_prior(bias)
    var table = uniformDraw(tables(cn))

    if(bias=='lawn'){
      if(table[1]<=globalStore.thetaCP){
        factor(-Math.log(thresholds.f))
      }
    }else if(bias=="BC-impossible-cons"){
      condition(pc(table) <= thresholds.f)
    }
    return {cn, table}
  }})
})
var all_states = state_prior("none").support()
display('# states: ')
display(all_states.length)

// Utterances and meaning ----------------------------------------------------
var literals_conjunctions = map(function(tokens){
  tokens.join(" and ")
}, combinations)
display('# literals + # conjunctions: ' + literals_conjunctions.length)

var literals = filter(function(utt){!utt.includes(" and ")},
                      literals_conjunctions)
var maybes = map(function(utt){'maybe ' + utt}, literals)
display('# maybe: ' + maybes.length)

var conditionals = combine_pairs(" > ")
display('# conditionals: ' + conditionals.length)

var utterances = literals_conjunctions.concat(conditionals.concat(maybes))
display('# all utterances: ' + utterances.length)
// map(display, utterances)

var utterance_probs = cache(function(utterance, state){
  if(conditionals.includes(utterance)){
    var components = utterance.split(" > ")
    var antecedent = components[0].split(" and ").join("")
    var consequent = components[1].split(" and ").join("")
    return marginal(state, [antecedent, consequent]) /
           marginal(state, [antecedent])
  }
  if(literals.includes(utterance)){return marginal(state, [utterance])}
  if(maybes.includes(utterance)){
    var u = utterance.slice("maybe ".length)
    return marginal(state, [u])
  }
  if(literals_conjunctions.includes(utterance)){
    var components = utterance.split(" and ")
    return marginal(state, components)
  }
  else{error("unknown utterance " + utterance)}
  return p
})

var meaning = cache(function(utterance, state){
 var p = utterance_probs(utterance, state)
 var u_applicable = utterance.includes('maybe') ?
     (p >= thresholds.theta_maybe) : p >= thresholds.theta
 return u_applicable
})

var utts_to_remove = filter(function(u){
  !any(function(s){meaning(u,s.table)}, all_states)
}, utterances)
display('# utts without corresponding state: ' + utts_to_remove.length)
// map(display, utts_to_remove)

var utterances = filter(function(u){!utts_to_remove.includes(u)}, utterances)
display('# included utterances: ' + utterances.length)

// Model ---------------------------------------------------------------------
var literal_listener = cache(function(utterance, bias){
  Infer({method:'enumerate',model: function(){
    var bn = sample(state_prior(bias))
    condition(meaning(utterance, bn.table))
    return bn
  }})
}, 10000)

var costs = function(utt){
  if(!utterances.includes(utt)){error('unknown utterance ' + utt)}
  var c1 = utt.includes(' > ') ? 0.55 : 0
  var c2 = (utt.split(' and ').length - 1) * 0.25
  var c3 = (utt.split('-').length - 1) * 0.125
  var c4 = utt.includes('maybe') ? 0.1 : 0
  return c1 + c2 + c3 + c4
}


var speaker = cache(function(bn, bias, displayU){
  return Infer({method:'enumerate', model: function(){
    var utterance = uniformDraw(utterances)
    var LL = literal_listener(utterance, bias)
    var utility = LL.score(bn)
    if(displayU && utility!=-Infinity){
      display(utterance + utility)
    }
    factor(globalStore.alpha * (utility - costs(utterance)))
    // factor(globalStore.alpha * utility)
    return utterance
  }
 })
}, 10000)

var listener = function(utterance, bias){
  return Infer({method:'enumerate', model:function(){
                  var bn = sample(state_prior(bias))
                  observe(speaker(bn, bias, false),utterance)
                  return bn
                }})
}

////////////  For model analysis  /////////////////
var conditions = {
  "pnc": function(bn){return marginal(bn.table, ["C"]) < thresholds.theta},
  "pc": function(bn){return marginal(bn.table, ["C"]) >= thresholds.theta &&
                            Math.exp(bn.table.score("AC")) < thresholds.theta &&
                            Math.exp(bn.table.score("-AC")) < thresholds.theta
                    },
  "pca": function(bn){
          return Math.exp(bn.table.score("AC")) >= thresholds.theta
         },
  "pcna": function(bn){
            return Math.exp(bn.table.score("-AC")) >= thresholds.theta
          },
  "no-condition": function(bn){return true}
}

var speaker_expectations = function(n, bias, cond){
  var prior = state_prior(bias)
  var prior = Infer({method:'enumerate', model:function(){
    var bn = sample(prior)

    var condFn = conditions[cond]
    var condHolds = condFn(bn)
    condition(condHolds)

    return bn
  }})
  display('# states in prior support: ' +  prior.support().length)
  display("sample BNs...")
  var bns = repeat(n, function(){return sample(prior)})
  display('# states: ' + bns.length)

  var likelihoods = map(function(utt){
      return sum(map(function(bn){
                      var speaker_beliefs = speaker(bn, bias, false)
                      var likelihood = Math.exp(speaker_beliefs.score(utt))
                      return likelihood
                     }, bns))/n
      }, utterances)

  return zip(utterances, likelihoods)
}

// Run from R ----------------------------------------------------------------

// var data = {
//   "utt": ["A > C"],
//   "bias": ["none"]
// }

var u = data["utt"][0]
var bias = data["bias"][0]

display("")
display("utterance: " + u)
display("bias: " + bias)

display("run LL ...")
var LL = literal_listener(u, bias)

display("run PL ...")
var PL = listener(u, bias)

display("run prior ...")
var prior = state_prior(bias)

// object to return
var distributions = {PL, LL, prior}
distributions