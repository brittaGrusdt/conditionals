let sigma = 0.05
// let w = 4
// let h = 6
// let s0 = {block1: {position: {x:10, y:2},
//            bounds: {max: {x: 10+ w/2}, min:{x: 10 - w/2}}
//           },
//           block2: {position: {x:16, y:2},
//                    bounds: {max: {x: 16 + w/2}, min:{x: 16 - w/2}}
//                   }
//          }
// let ground = {position: {x:10, y:10}, bounds: {max: {x: 20}, min:{x: 0}}}

// distribution over x positions of 2 relevant blocks in a single situation
let Distr = function(blocks){

  return Infer({method: "MCMC", samples: 1000, burn: 100, model: function(){
    let inCanvas = [];
    let xSamples = map(function(block){
      // we only have uncertainty in x, not in y
      let x = gaussian({mu: block.position.x, sigma})

      let widthHalf = (block.bounds.max.x - block.bounds.min.x) / 2
      let aboveMin = x - widthHalf >= 0
      let belowMax = x + widthHalf <= ground.bounds.max.x
      inCanvas.push(aboveMin && belowMax)

      return x
    }, Object.values(blocks));

    // block2 is always stacked on top of block1
    let b1 = blocks.block1
    let b2 = blocks.block2

    // x-positions must have overlap for stacked blocks, mustn't for blocks
    // side-by-side
    let posIsValid = b2.stacked ? (!(b2.bounds.max.x < b1.bounds.min) &&
                                   !(b2.bounds.min.x > b1.bounds.max.x))
                                : (b2.bounds.min.x >= b1.bounds.max.x ||
                                   b2.bounds.max.x <= b1.bounds.min.x)

    condition(posIsValid)

    return xSamples
  }});
}
