// Parameters ----------------------------------------------------------------
globalStore.alpha = 5
globalStore.thetaCP = 0.05
var thresholds = {t: 0.899, f: 0.0499, theta: 0.899, theta_maybe : 0.499}
var verbose = data["verbose"][0]
var tables_list = data["tables"]
var noise_v = data["noise_v"][0]
var causal_nets = data["cns"]
var bias = data["bias"][0]
var cn = data["cn"][0]

var vars = [["A", "-A"], ["C", "-C"]]
var p_ac_ind = {"none": 1/2,
                "lawn": 0.1,
                "pizza" : 1,
                "BC-impossible-cons": 1
                }
// // measurement: |P(C,A) - P(C) * P(A)|
// var beta_ind = {
//   5 : 25,
//   10 : 30,
//   20 : 35,
//   50 : 50,
//   100 : 70,
//   250 :110,
//   500 : 150
// }

// // measurement: |P(C|A) - P(C|-A)|
var beta_ind = {
  5 : 3,
  10 : 3.5,
  20 : 5,
  50 : 7,
  100 : 10,
  250 :15,
  500 : 20
}
var c = 1
// measurement: |P(C|A) - P(C)|
// var beta_ind = {
//   5 : 8,
//   10 : 9,
//   20 : 15,
//   50 : 20,
//   100 : 25,
//   250 :50,
//   500 : 75
// }



var tables = map(function(obj){
  Categorical({"vs": obj["vs"], "ps": obj["ps"]})
}, tables_list)
if(verbose){
  display('# tables: ' + tables.length)
  display('beta param for independent likelihood: ' + beta_ind[noise_v])
}
display('table distributions generated.')
// Helper --------------------------------------------------------------------
var intersect_arrays = function(arrays){
  return filter(function(m){
          var m_in_all_lists = map(function(idx){arrays[idx].includes(m)},
                                  _.range(1,arrays.length))
          return sum(m_in_all_lists)==m_in_all_lists.length
    }, arrays[0])
}

// Probabilities ------------------------------------------------------------
var marginal = cache(function(table, variables){
  // computes the probability of P(A) marginalized over all other variables in
  // support of table with P=table and variables=["A"]
  var tokens = table.support()
  var all_x = map(function(v){
    v.includes("-") ? filter(function(k){k.includes(v)}, tokens) :
                      filter(function(k){!k.includes("-"+v)}, tokens)
  }, variables)
  var xs = intersect_arrays(all_x)

  return reduce(function(x, acc){acc + Math.exp(table.score(x))}, 0, xs)
})

var marginal_probs = cache(function(table){
  return {"P(C|A)" : marginal(table, ["A", "C"]) / marginal(table, ["A"]),
          "P(C|-A)": marginal(table, ["-A", "C"]) / marginal(table, ["-A"]),
          "P(A|C)" : marginal(table, ["A", "C"]) / marginal(table, ["C"]),
          "P(A|-C)": marginal(table, ["A", "-C"]) / marginal(table, ["-C"])}
}, 10000)

var cn_to_prob = function(state){
  var cn = state.cn
  var table = state.table
  var probs = marginal_probs(table)
  return cn == "A implies C" ? [probs["P(C|A)"], probs["P(C|-A)"]] :
         cn == "A implies -C" ? [1 - probs["P(C|A)"], 1 - probs["P(C|-A)"]] :
         cn == "-A implies C" ? [probs["P(C|-A)"], probs["P(C|A)"]] :
         cn == "-A implies -C" ? [1 - probs["P(C|-A)"], 1 - probs["P(C|A)"]] :
         cn == "C implies A" ? [probs["P(A|C)"], probs["P(A|-C)"]] :
         cn == "C implies -A" ? [1 - probs["P(A|C)"], 1 - probs["P(A|-C)"]] :
         cn == "-C implies A" ? [probs["P(A|-C)"], probs["P(A|C)"]] :
         cn == "-C implies -A" ? [1 - probs["P(A|-C)"], 1 - probs["P(A|C)"]] :
         cn == "A || C" ? Math.abs(probs["P(C|A)"] - probs["P(C|-A)"]) :

         // Math.abs(marginal(table, ["A", "C"]) -
                              // (marginal(table, ["A"]) * marginal(table, ["C"]))
                                  // ) :
  error('unknown network: ' + cn)
}

// State prior  --------------------------------------------------------------
var cn_prior = function(bias) {
  var p_ind = p_ac_ind[bias]
  var p_dep = (1 - p_ind) / (causal_nets.length-1)
  var ps = map(function(cn){cn=="A || C" ?  p_ind : p_dep}, causal_nets)
  return categorical({vs: causal_nets, ps: ps})
}

var log_likelihood = function(state){
  var p = cn_to_prob(state)
  return state.cn == "A || C" ? c * Beta({a:1, b: beta_ind[noise_v]}).score(p)
                              : Beta({a:10, b:1}).score(p[0]) //+
                                 // Beta({a:1, b:10}).score(p[1]))
  // (p==0 ? -Math.log(as_if_zero) : -Math.log(p))
  // (p == 0 ? Math.log(1/(10*as_if_zero)) : Math.log(1/(10*p)))
}

var state_prior = cache(function(bias){
  return Infer({method:'enumerate', model:function(){
    var state = {"table": uniformDraw(tables),
                 "cn": cn_prior(bias)}
    return state
  }})
})



var ll = map(function(s){
  return {"cn": s.cn, "logL": log_likelihood(s)}
}, state_prior(bias).support())
ll
